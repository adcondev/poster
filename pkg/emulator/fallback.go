package emulator

import (
	"image/color"
	"image/draw"
	"unicode"
)

// UseFallback returns true if fallback bitmap rendering should be used
func (fm *FontManager) UseFallback() bool {
	return fm.useFallback
}

// drawFallbackChar renders a basic bitmap character when fonts aren't available
func (fm *FontManager) drawFallbackChar(dst draw.Image, char rune, x, y, w, h int, col color.Color) {
	// Simple 5x7 bitmap font patterns for basic ASCII
	// This is a minimal fallback - real implementation would have full charset
	patterns := getFallbackPattern(char)

	scaleX := w / 6 // 5 pixels + 1 spacing
	scaleY := h / 8 // 7 pixels + 1 spacing
	if scaleX < 1 {
		scaleX = 1
	}
	if scaleY < 1 {
		scaleY = 1
	}

	for py := 0; py < 7; py++ {
		for px := 0; px < 5; px++ {
			if patterns[py]&(1<<(4-px)) != 0 {
				// Draw scaled pixel
				for sy := 0; sy < scaleY; sy++ {
					for sx := 0; sx < scaleX; sx++ {
						dst.Set(x+px*scaleX+sx, y-h+py*scaleY+sy, col)
					}
				}
			}
		}
	}
}

// getFallbackPattern returns a 5x7 bitmap pattern for a character
func getFallbackPattern(char rune) [7]byte {
	// Convert to uppercase first
	char = unicode.ToUpper(char)

	// Basic ASCII patterns (5 bits per row, 7 rows)
	patterns := map[rune][7]byte{
		' ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'A': {0x0E, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11},
		'B': {0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E},
		'C': {0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E},
		'D': {0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E},
		'E': {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F},
		'F': {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10},
		'G': {0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0E},
		'H': {0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11},
		'I': {0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E},
		'J': {0x1F, 0x04, 0x04, 0x04, 0x04, 0x14, 0x08},
		'K': {0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11},
		'L': {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F},
		'M': {0x11, 0x1B, 0x15, 0x11, 0x11, 0x11, 0x11},
		'N': {0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x11},
		'O': {0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},
		'P': {0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10},
		'Q': {0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0D},
		'R': {0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11},
		'S': {0x0E, 0x11, 0x10, 0x0E, 0x01, 0x11, 0x0E},
		'T': {0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04},
		'U': {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},
		'V': {0x11, 0x11, 0x11, 0x11, 0x0A, 0x0A, 0x04},
		'W': {0x11, 0x11, 0x11, 0x15, 0x15, 0x0A, 0x0A},
		'X': {0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11},
		'Y': {0x11, 0x11, 0x0A, 0x04, 0x04, 0x04, 0x04},
		'Z': {0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F},
		'0': {0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E},
		'1': {0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E},
		'2': {0x0E, 0x11, 0x01, 0x06, 0x08, 0x10, 0x1F},
		'3': {0x0E, 0x11, 0x01, 0x06, 0x01, 0x11, 0x0E},
		'4': {0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02},
		'5': {0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E},
		'6': {0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E},
		'7': {0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08},
		'8': {0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E},
		'9': {0x0E, 0x11, 0x11, 0x1F, 0x01, 0x02, 0x0C},
		'-': {0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00},
		'=': {0x00, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x00},
		'.': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06},
		',': {0x00, 0x00, 0x00, 0x00, 0x06, 0x02, 0x04},
		':': {0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00},
		'$': {0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04},
		'#': {0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A},
		'!': {0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04},
		'?': {0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04},
		'/': {0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10},
		'*': {0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00},
		'+': {0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00},
		'(': {0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02},
		')': {0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08},
		// Extended Latin characters for Spanish/Portuguese support
		// N with tilde: Tilde on Row 0, Compressed N on Rows 1-6
		'Ñ': {0x0E, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11},
		// Lowercase n with tilde
		'Á': {0x02, 0x04, 0x0E, 0x11, 0x1F, 0x11, 0x11},
		'É': {0x02, 0x04, 0x1F, 0x10, 0x1E, 0x10, 0x1F},
		'Í': {0x02, 0x04, 0x0E, 0x04, 0x04, 0x04, 0x0E},
		'Ó': {0x02, 0x04, 0x0E, 0x11, 0x11, 0x11, 0x0E},
		'Ú': {0x02, 0x04, 0x11, 0x11, 0x11, 0x11, 0x0E},
		'Ü': {0x0A, 0x00, 0x11, 0x11, 0x11, 0x11, 0x0E},
		'¿': {0x04, 0x00, 0x04, 0x08, 0x10, 0x11, 0x0E},
		'¡': {0x04, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04},
	}

	// Check for match (already uppercase)
	if p, ok := patterns[char]; ok {
		return p
	}

	// Default: filled rectangle for unknown chars
	return [7]byte{0x1F, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1F}
}
